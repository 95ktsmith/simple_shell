.TH man 1 "16 April 2020" "1.0" "hsh man page"
.SH NAME
.B simple shell
- Holberton SHell command interpreter.
.SH SYNOPSIS

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stddef.h>
#include <string.h>

/**
 * struct params - parameter struct
 * @loop_count: Number of loops or inputs since the shell was started
 * @shellname: Name of the file the shell was run as
 * @args: Tokenized list of arguments from getline
 * @env: Environment
 */
typedef struct params
{
	size_t loop_count;
	char *shellname;
	char **args;
	char **env;
} param_t;

/**
 * struct env_node - Environment node struct
 * @var: Envrionment variable name
 * @val: Variable value
 * @next: Next node in linked list
 */
typedef struct env_node
{
	char *var;
	char *val;
	struct env_node *next;
} env_t;

/**
 * struct builtin - Builtin function struct
 * @name: Name of the builtin command
 * @f: The Function associated with that name
 */
typedef struct builtin
{
	char *name;
	void (*f)(param_t *params);
} builtin_t;

/* main */

   int find_and_exec(param_t *params);
   void (*get_builtin(char *name))(param_t *params);

/* builtins_1 */

   void exit_shell(param_t *params);
   void print_env(param_t *params);

/* _getenv */

   char *check_file(param_t *params);
   char *find_in_path(param_t *params);
   char *_getenv(char *var, char *env[]);
   char *find_in_pwd(param_t *params);

/* ffree */

   void free_params(param_t *params);
   void clean_exit(param_t *params, int status);
   void free_env(env_t *head);
   void ffree(const char *fmt, ...);

/* getargs */

   char **getline_to_args(ssize_t *nbytes, FILE *stream, param_t *params);

/* listfuncs */

   size_t _pow(size_t a, size_t b);
   int _strcmp(char *s1, char *s2);
   env_t *env_to_list(char *env[]);
   env_t *add_env_node(env_t **head, char *var, char *val);
   char *_getenv_node(char *var, env_t *head);

/* error funcs */

   size_t _pow(size_t a, size_t b);
   void stoa(size_t value, char *buffer, size_t base);
   ssize_t write_error(param_t *params, char *msg);

/* strfuncs */

   char *_strdup(char *);
   char *_strchr(char *, char);
   char *_strstr(char *haystack, char *needle);
   char *str_concat(char *s1, char *s2);
   int _strlen(char *s);

/* _strtok */

   int token_count(char *, char);
   char **_strtok(char *str, char delim, param_t *params);
   void free_array(char **tokens);


.SH DESCRIPTION
.B Overview

Holberton shell is a simple command interpreter.  Only a few of the features designated by POSIX, are being incorporated into this shell.  This man page is not intended to be a tutorial or a complete specification of the shell. The shell is a command that reads lines from either a file or the terminal, interprets them, and generally executes other commands.  It is the program that is running when a user logs into the system (although a user can select a different shell with the chsh(1) command).  The shell implements a language that has flow control constructs, a macro facility that provides a variety of features in addition to data storage, along with built in history and line editing capabilities.  It incorporates many features to aid interactive use and has the advantage that the interpretative language is common to both interactive and non-interactive use (shell scripts).  That is, commands can be typed directly to the running shell or can be put into a file and the file can be executed directly by the shell.

.B Invocation

If no args are present and if the standard input of the shell is connected to a terminal, the shell is considered an interactive shell.  An interactive shell generally prompts before each command and handles program ming and command errors differently (as described below).  This is normally done automatically  when the user first logs in.  A login shell first reads commands from the files /etc/profile and .profile if they exist.  If the environment variable ENV is set on entry to an interactive shell, or is set in the .profile of a login shell, the shell next reads commands from the file named in ENV.  If command line arguments besides the options have been specified, then the shell treats the first argument as the name of a file from which to read commands (a shell script), and the remaining arguments are set as the positional parameters of the shell (stdout, stderr, etc).  Otherwise, the shell reads commands from its standard input.


.SH OPTIONS

Syntax Structure

The shell reads input in terms of lines from a file and breaks it up into words at whitespace (blanks and tabs), and at certain sequences of characters that are special to the shell called “operators”.  There are two types of operators: control operators and redirection operators (their meaning is discussed later).  Following is a list of operators:

           Control operators:
                 & && ( ) ; ;; | || <newline>

           Redirection operators:
                 < > >| << >> <& >& <<- <>

Quoting

Quoting is used to remove the special meaning of certain characters or words to the shell, such as operators, whitespace, or keywords.  There are three types of quoting: matched single quotes, matched double quotes, and backslash.

Backslash

A backslash preserves the literal meaning of the following character, with the exception of ⟨newline⟩.  A backslash preceding a ⟨newline⟩ is treated as a line continuation.

Single Quotes
Enclosing characters in single quotes preserves the literal meaning of all the characters (except single quotes, making it impossible to put single-quotes in a single-quoted string).

Double Quotes
Enclosing characters within double quotes preserves the literal meaning of all characters except dollarsign ($), backquote (`), and back slash (\).  The backslash inside double quotes is historically weird, and serves to quote only the following characters: $ ` " \ <newline>.  Otherwise it remains literal.

Aliases
An alias is a name and corresponding value set using the alias(1) builtin command.  Whenever a reserved word may occur (see above), and after checking for reserved words, the shell checks the word to see if it matches an alias.  If it does, it replaces it in the input stream with its value.  Aliases provide a convenient way for naive users to create shorthands for commands without having to learn how to create functions with arguments.

Simple Commands
If a simple command has been recognized, the shell performs the following actions:

   1.   Leading words of the form “name=value” are stripped off and assigned to the environment of the simple command.  Redirection operators and their arguments (as described below) are stripped off and saved for processing.

   2.   The remaining words are expanded as described in the section called “Expansions”, and the first remaining word is considered the command name and the command is located.  The remaining words are considered the arguments of the command.  If no command name resulted, then the “name=value” variable assignments recognized in item 1 affect the current shell.

   3.   Redirections are performed as described in the next section.

Redirections
Redirections are used to change where a command reads its input or sends its output.  In general, redirections open, close, or duplicate an existing reference to a file.  The overall format used for redirection is:

           [n] redir-op file

where redir-op is one of the redirection operators mentioned previously.  Following is a list of the possible redirections.  The [n] is an optional number, as in ‘3’ (not ‘[3]’), that refers to a file descriptor.

           [n]> file   Redirect standard output (or n) to file.

           [n]>| file  Same, but override the -C option.

           [n]>> file  Append standard output (or n) to file.

           [n]< file   Redirect standard input (or n) from file.

           [n1]<&n2    Duplicate standard input (or n1) from file descriptor n2.

           [n]<&-      Close standard input (or n).

           [n1]>&n2    Duplicate standard output (or n1) to n2.

           [n]>&-      Close standard output (or n).

           [n]<> file  Open file for reading and writing on standard input (or n).

Search and Execution

There are three types of commands: shell functions, builtin commands, and normal programs -- and the command is searched for (by name) in that order.  They each are executed in a different way.

When a shell function is executed, all of the shell positional parameters (except $0, which remains unchanged) are set to the arguments of the shell function.  The variables which are explicitly placed in the environment of the command (by placing assignments to them before the function name) are made local to the function and are set to the values given.  Then the command given in the function definition is executed.  The positional parameters are restored to their original values when the command completes.  This all occurs within the current shell.

Shell builtins are executed internally to the shell, without spawning a new process.

Otherwise, if the command name doesn't match a function or builtin, the command is searched for as a normal program in the file system (as described in the next section).  When a normal program is executed, the shell runs the program, passing the arguments and the environment to the program.  If the program is not a normal executable file (i.e., if it does not begin with the "magic number" whose ASCII representation is "#!", so execve(2) returns ENOEXEC then) the shell will interpret the program in a subshell.  The child shell will reinitialize itself in this case, so that the effect will be as if a new shell had been invoked to handle the ad-hoc shell script, except that the location of hashed commands located in the parent shell will be remembered by the child.

Path Search
When locating a command, the shell first looks to see if it has a shell function by that name.  Then it looks for a builtin command by that name.  If a builtin command is not found, one of two things happen:

1.   Command names containing a slash are simply executed without performing any searches.

2.   The shell searches each entry in PATH in turn for the command.  The value of the PATH variable should be a series of entries separated by colons.  Each entry consists of a directory name.  The current directory may be indicated implicitly by an empty directory name, or explicitly by a single period.

Command Exit Status
Each command has an exit status that can influence the behaviour of other shell commands.  The paradigm is that a command exits with zero for normal or success, and non-zero for failure, error, or a false indication.  The man page for each command should indicate the various exit codes and what they mean.  Additionally, the builtin commands return exit codes, as does an executed shell function.  If a command consists entirely of variable assignments then the exit status of the command is that of the last command substitution if any, otherwise 0.

Complex Commands
Complex commands are combinations of simple commands with control operators or reserved words, together creating a larger complex command.  More generally, a command is one of the following:

     ·   simple command

     ·   pipeline

     ·   list or compound-list

     ·   compound command

     ·   function definition

     Unless otherwise stated, the exit status of a command is that of the last simple command executed by the command.

Pipelines
A pipeline is a sequence of one or more commands separated by the control operator |.  The standard output of all but the last command is connected to the standard input of the next command.  The standard output of the last command is inherited from the shell, as usual.

The format for a pipeline is:

           [!] command1 [| command2 ...]

The standard output of command1 is connected to the standard input of command2.  The standard input, standard output, or both of a command is considered to be assigned by the pipeline before any redirection specified by redirection operators that are part of the command.

If the pipeline is not in the background (discussed later), the shell waits for all commands to complete.

If the reserved word ! does not precede the pipeline, the exit status is the exit status of the last command specified in the pipeline.  Otherwise, the exit status is the logical NOT of the exit status of the last command.  That is, if the last command returns zero, the exit status is 1; if the last command returns greater than zero, the exit status is zero.

Because pipeline assignment of standard input or standard output or both takes place before redirection, it can be modified by redirection.
     For example:

           $ command1 2>&1 | command2

     sends both the standard output and standard error of command1 to the standard input of command2.

     A ; or ⟨newline⟩ terminator causes the preceding AND-OR-list (described next) to be executed sequentially; a & causes asynchronous execu‐
     tion of the preceding AND-OR-list.

     Note that unlike some other shells, each process in the pipeline is a child of the invoking shell (unless it is a shell builtin, in which
     case it executes in the current shell -- but any effect it has on the environment is wiped).

Background Commands -- &
     If a command is terminated by the control operator ampersand (&), the shell executes the command asynchronously -- that is, the shell does
     not wait for the command to finish before executing the next command.

     The format for running a command in background is:

           command1 & [command2 & ...]

     If the shell is not interactive, the standard input of an asynchronous command is set to /dev/null.

Lists -- Generally Speaking
     A list is a sequence of zero or more commands separated by newlines, semicolons, or ampersands, and optionally terminated by one of these
     three characters.  The commands in a list are executed in the order they are written.  If command is followed by an ampersand, the shell
     starts the command and immediately proceed onto the next command; otherwise it waits for the command to terminate before proceeding to the
     next one.

Short-Circuit List Operators
     “&&” and “||” are AND-OR list operators.  “&&” executes the first command, and then executes the second command iff the exit status of the
     first command is zero.  “||” is similar, but executes the second command iff the exit status of the first command is nonzero.  “&&” and
     “||” both have the same priority.

Variables and Parameters
     The shell maintains a set of parameters.  A parameter denoted by a name is called a variable.  When starting up, the shell turns all the
     environment variables into shell variables.  New variables can be set using the form

           name=value

     Variables set by the user must have a name consisting solely of alphabetics, numerics, and underscores - the first of which must not be
     numeric.  A parameter can also be denoted by a number or a special character as explained below.

   Special Parameters
     A special parameter is a parameter denoted by one of the following special characters.  The value of the parameter is listed next to its
     character.

     *            Expands to the positional parameters, starting from one.  When the expansion occurs within a double-quoted string it expands
                  to a single field with the value of each parameter separated by the first character of the IFS variable, or by a ⟨space⟩ if
                  IFS is unset.

     @            Expands to the positional parameters, starting from one.  When the expansion occurs within double-quotes, each positional
                  parameter expands as a separate argument.  If there are no positional parameters, the expansion of @ generates zero arguments,
                  even when @ is double-quoted.  What this basically means, for example, is if $1 is “abc” and $2 is “def ghi”, then "$@"
                  expands to the two arguments:

                        "abc" "def ghi"

     #            Expands to the number of positional parameters.

     ?            Expands to the exit status of the most recent pipeline.

     - (Hyphen.)  Expands to the current option flags (the single-letter option names concatenated into a string) as specified on invocation, by
                  the set builtin command, or implicitly by the shell.

     $            Expands to the process ID of the invoked shell.  A subshell retains the same value of $ as its parent.

     !            Expands to the process ID of the most recent background command executed from the current shell.  For a pipeline, the process
                  ID is that of the last command in the pipeline.

     0 (Zero.)    Expands to the name of the shell or shell script.

   Word Expansions
     This clause describes the various expansions that are performed on words.  Not all expansions are performed on every word, as explained
     later.

     Tilde expansions, parameter expansions, command substitutions, arithmetic expansions, and quote removals that occur within a single word
     expand to a single field.  It is only field splitting or pathname expansion that can create multiple fields from a single word.

     The order of word expansion is:

     1.   Tilde Expansion, Parameter Expansion, Command Substitution, Arithmetic Expansion (these all occur at the same time).

     2.   Field Splitting is performed on fields generated by step (1) unless the IFS variable is null.

     3.   Pathname Expansion (unless set -f is in effect).

     4.   Quote Removal.

     The $ character is used to introduce parameter expansion, command substitution, or arithmetic evaluation.

.SH SEE ALSO
.I peerlearning(2), projectbased(2), fullstack(2), Betty(1)
.SH BUGS
Holder.
.SH AUTHOR
Amilcar Armmand and Kevin Smith


*********
   Tilde Expansion (substituting a user's home directory)
     A word beginning with an unquoted tilde character (~) is subjected to tilde expansion.  All the characters up to a slash (/) or the end of
     the word are treated as a username and are replaced with the user's home directory.  If the username is missing (as in ~/foobar), the tilde
     is replaced with the value of the HOME variable (the current user's home directory).

   Parameter Expansion
     The format for parameter expansion is as follows:

           ${expression}

     where expression consists of all characters until the matching “}”.  Any “}” escaped by a backslash or within a quoted string, and charac‐
     ters in embedded arithmetic expansions, command substitutions, and variable expansions, are not examined in determining the matching “}”.

     The simplest form for parameter expansion is:

           ${parameter}

     The value, if any, of parameter is substituted.

     The parameter name or symbol can be enclosed in braces, which are optional except for positional parameters with more than one digit or
     when parameter is followed by a character that could be interpreted as part of the name.  If a parameter expansion occurs inside double-
     quotes:

     1.   Pathname expansion is not performed on the results of the expansion.

     2.   Field splitting is not performed on the results of the expansion, with the exception of @.

     In addition, a parameter expansion can be modified by using one of the following formats.

     ${parameter:-word}    Use Default Values.  If parameter is unset or null, the expansion of word is substituted; otherwise, the value of
                           parameter is substituted.

     ${parameter:=word}    Assign Default Values.  If parameter is unset or null, the expansion of word is assigned to parameter.  In all cases,
                           the final value of parameter is substituted.  Only variables, not positional parameters or special parameters, can be
                           assigned in this way.

     ${parameter:?[word]}  Indicate Error if Null or Unset.  If parameter is unset or null, the expansion of word (or a message indicating it is
                           unset if word is omitted) is written to standard error and the shell exits with a nonzero exit status.  Otherwise,
                           the value of parameter is substituted.  An interactive shell need not exit.

     ${parameter:+word}    Use Alternative Value.  If parameter is unset or null, null is substituted; otherwise, the expansion of word is sub‐
                           stituted.

     In the parameter expansions shown previously, use of the colon in the format results in a test for a parameter that is unset or null; omis‐
     sion of the colon results in a test for a parameter that is only unset.

     ${#parameter}         String Length.  The length in characters of the value of parameter.

     The following four varieties of parameter expansion provide for substring processing.  In each case, pattern matching notation (see Shell
     Patterns), rather than regular expression notation, is used to evaluate the patterns.  If parameter is * or @, the result of the expansion
     is unspecified.  Enclosing the full parameter expansion string in double-quotes does not cause the following four varieties of pattern
     characters to be quoted, whereas quoting characters within the braces has this effect.

     ${parameter%word}     Remove Smallest Suffix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in
                           parameter, with the smallest portion of the suffix matched by the pattern deleted.

     ${parameter%%word}    Remove Largest Suffix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in
                           parameter, with the largest portion of the suffix matched by the pattern deleted.

     ${parameter#word}     Remove Smallest Prefix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in
                           parameter, with the smallest portion of the prefix matched by the pattern deleted.

     ${parameter##word}    Remove Largest Prefix Pattern.  The word is expanded to produce a pattern.  The parameter expansion then results in
                           parameter, with the largest portion of the prefix matched by the pattern deleted.

   Command Substitution
     Command substitution allows the output of a command to be substituted in place of the command name itself.  Command substitution occurs
     when the command is enclosed as follows:

           $(command)

     or (“backquoted” version):

           `command`

     The shell expands the command substitution by executing command in a subshell environment and replacing the command substitution with the
     standard output of the command, removing sequences of one or more ⟨newline⟩s at the end of the substitution.  (Embedded ⟨newline⟩s before
     the end of the output are not removed; however, during field splitting, they may be translated into ⟨space⟩s, depending on the value of IFS
     and quoting that is in effect.)

   Arithmetic Expansion
     Arithmetic expansion provides a mechanism for evaluating an arithmetic expression and substituting its value.  The format for arithmetic
     expansion is as follows:

           $((expression))

     The expression is treated as if it were in double-quotes, except that a double-quote inside the expression is not treated specially.  The
     shell expands all tokens in the expression for parameter expansion, command substitution, and quote removal.

     Next, the shell treats this as an arithmetic expression and substitutes the value of the expression.

   White Space Splitting (Field Splitting)
     After parameter expansion, command substitution, and arithmetic expansion the shell scans the results of expansions and substitutions that
     did not occur in double-quotes for field splitting and multiple fields can result.

     The shell treats each character of the IFS as a delimiter and uses the delimiters to split the results of parameter expansion and command
     substitution into fields.

   Pathname Expansion (File Name Generation)
     Unless the -f flag is set, file name generation is performed after word splitting is complete.  Each word is viewed as a series of pat‐
     terns, separated by slashes.  The process of expansion replaces the word with the names of all existing files whose names can be formed by
     replacing each pattern with a string that matches the specified pattern.  There are two restrictions on this: first, a pattern cannot match
     a string containing a slash, and second, a pattern cannot match a string starting with a period unless the first character of the pattern
     is a period.  The next section describes the patterns used for both Pathname Expansion and the case command.

   Shell Patterns
     A pattern consists of normal characters, which match themselves, and meta-characters.  The meta-characters are “!”, “*”, “?”, and “[”.
     These characters lose their special meanings if they are quoted.  When command or variable substitution is performed and the dollar sign or
     back quotes are not double quoted, the value of the variable or the output of the command is scanned for these characters and they are
     turned into meta-characters.

     An asterisk (“*”) matches any string of characters.  A question mark matches any single character.  A left bracket (“[”) introduces a char‐
     acter class.  The end of the character class is indicated by a (“]”); if the “]” is missing then the “[” matches a “[” rather than intro‐
     ducing a character class.  A character class matches any of the characters between the square brackets.  A range of characters may be spec‐
     ified using a minus sign.  The character class may be complemented by making an exclamation point the first character of the character
     class.

     To include a “]” in a character class, make it the first character listed (after the “!”, if any).  To include a minus sign, make it the
     first or last character listed.

   Builtins
     This section lists the builtin commands which are builtin because they need to perform some operation that can't be performed by a separate
     process.  In addition to these, there are several other commands that may be builtin for efficiency (e.g.  printf(1), echo(1), test(1),
     etc).

     :

     true   A null command that returns a 0 (true) exit value.

     . file
            The commands in the specified file are read and executed by the shell.

     alias [name[=string ...]]
            If name=string is specified, the shell defines the alias name with value string.  If just name is specified, the value of the alias
            name is printed.  With no arguments, the alias builtin prints the names and values of all defined aliases (see unalias).

     bg [job] ...
            Continue the specified jobs (or the current job if no jobs are given) in the background.

     command [-p] [-v] [-V] command [arg ...]
            Execute the specified command but ignore shell functions when searching for it.  (This is useful when you have a shell function with
            the same name as a builtin command.)

            -p     search for command using a PATH that guarantees to find all the standard utilities.

            -V     Do not execute the command but search for the command and print the resolution of the command search.  This is the same as
                   the type builtin.

            -v     Do not execute the command but search for the command and print the absolute pathname of utilities, the name for builtins or
                   the expansion of aliases.

     cd -

     cd [-LP] [directory]
            Switch to the specified directory (default HOME).  If an entry for CDPATH appears in the environment of the cd command or the shell
            variable CDPATH is set and the directory name does not begin with a slash, then the directories listed in CDPATH will be searched
            for the specified directory.  The format of CDPATH is the same as that of PATH.  If a single dash is specified as the argument, it
            will be replaced by the value of OLDPWD.  The cd command will print out the name of the directory that it actually switched to if
            this is different from the name that the user gave.  These may be different either because the CDPATH mechanism was used or because
            the argument is a single dash.  The -P option causes the physical directory structure to be used, that is, all symbolic links are
            resolved to their respective values.  The -L option turns off the effect of any preceding -P options.

     echo [-n] args...
            Print the arguments on the standard output, separated by spaces.  Unless the -n option is present, a newline is output following the arguments.

            If any of the following sequences of characters is encountered during output, the sequence is not output.  Instead, the specified
            action is performed:

            \b      A backspace character is output.

            \c      Subsequent output is suppressed.  This is normally used at the end of the last argument to suppress the trailing newline
                    that echo would otherwise output.

            \f      Output a form feed.

            \n      Output a newline character.

            \r      Output a carriage return.

            \t      Output a (horizontal) tab character.

            \v      Output a vertical tab.

     unalias [-a] [name]
            If name is specified, the shell removes that alias.  If -a is specified, all aliases are removed.

     unset [-fv] name ...
            The specified variables and functions are unset and unexported.  If -f or -v is specified, the corresponding function or variable is
            unset, respectively.  If a given name corresponds to both a variable and a function, and no options are given, only the variable is
            unset.

     wait [job]
            Wait for the specified job to complete and return the exit status of the last process in the job.  If the argument is omitted, wait
            for all jobs to complete and the return an exit status of zero.

EXIT STATUS
     Errors that are detected by the shell, such as a syntax error, will cause the shell to exit with a non-zero exit status.  If the shell is not an interactive shell, the execution of the shell file will be aborted.  Otherwise the shell will return the exit status of the last command executed, or if the exit builtin is used with a numeric argument, it will return the argument.
